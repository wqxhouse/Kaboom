#include "InputSystem.h"

#include <btBulletDynamicsCommon.h>

#include <components/PositionComponent.h>
#include <components/RotationComponent.h>
#include <components/PlayerStatusComponent.h>
#include <core/EntityManager.h>

#include "../components/InputComponent.h"
#include "../components/PhysicsComponent.h"
#include "../components/JetpackComponent.h"
#include "../core/Game.h"
#include "../math/util.h"

#define VELOCITYCAP 2
#define VELOCTIYACCELERATION .1

InputSystem::InputSystem(Game *game)
        : game(game) {
}

bool InputSystem::checkEntity(Entity *entity) {
    return entity->hasComponent<PositionComponent>() &&
            entity->hasComponent<RotationComponent>() &&
            entity->hasComponent<PhysicsComponent>() &&
            entity->hasComponent<InputComponent>() &&
            entity->hasComponent<PlayerStatusComponent>();
}

void InputSystem::processEntity(Entity *entity) {
    InputComponent *inputComp = entity->getComponent<InputComponent>();
    PositionComponent *posComp = entity->getComponent<PositionComponent>();
    RotationComponent *rotComp = entity->getComponent<RotationComponent>();
    PhysicsComponent *physComp = entity->getComponent<PhysicsComponent>();
    PlayerStatusComponent *playerStatusComp = entity->getComponent<PlayerStatusComponent>();

    btRigidBody *rigidBody = physComp->getRigidBody();
    btVector3 velocity = rigidBody->getLinearVelocity();

    // TODO: currently, forward & backward event will override 
    // the front and right velocity generated by the physics.
    // Only velocity on the z axis is taken from the physics calc

    btVector3 walkDir = getViewDirection(
            posComp->getX(),
            posComp->getY(),
            posComp->getZ(),
            rotComp->getYaw(),
            0);

    // construct local coordinate system
    btVector3 front = walkDir;
    btVector3 right = front.cross(btVector3(0, 0, 1));
    right.normalize();
    // do not calculate head vector, since gravity is always neg z

    btVector3 localVelocity(0.0, 0.0, 0.0);

    // Define y to be front speed, x to be right speed
    if (inputComp->isMovingForward()) {
        localVelocity.setY(2);
    } else if (inputComp->isMovingBackward()) {
        localVelocity.setY(-2);
    } else {
        localVelocity.setY(0);
    }

    if (inputComp->isMovingLeft()) {
        localVelocity.setX(-2);
    } else if (inputComp->isMovingRight()) {
        localVelocity.setX(2);
    } else {
        localVelocity.setX(0);
    }

    JetpackComponent *jetComp = entity->getComponent<JetpackComponent>();

    if (jetComp != nullptr) {
        if (inputComp->isJumping()) {

            if (!jetComp->activateJetpack()) {
                jetComp->refillJetpack();
            } else {
                if (velocity.getZ() > VELOCITYCAP) {
                    velocity.setZ(VELOCITYCAP);
                } else {
                    velocity.setZ(velocity.getZ() + VELOCTIYACCELERATION);
                }
            }
        } else {
            jetComp->refillJetpack();
        }
    }

    btVector3 worldVelocity(right * localVelocity.getX() + front * localVelocity.getY());
    worldVelocity.setZ(velocity.getZ());

    if (!playerStatusComp->checkIsKnockBacked()) { //don't move if we are knockbacked
        rigidBody->setLinearVelocity(worldVelocity);
    }
}
