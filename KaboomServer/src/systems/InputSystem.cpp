#include "InputSystem.h"

#include <btBulletDynamicsCommon.h>

#include <components/PositionComponent.h>
#include <components/PlayerStatusComponent.h>
#include <components/RotationComponent.h>
#include <core/EntityManager.h>

#include "../components/DestroyComponent.h"
#include "../components/InputComponent.h"
#include "../components/PhysicsComponent.h"
#include "../components/JetpackComponent.h"
#include "../components/JumpComponent.h"
#include "../core/EntityConfigLookup.h"
#include "../core/Game.h"
#include "../math/util.h"

#define VELOCITYCAP 2
#define VELOCTIYACCELERATION .1

InputSystem::InputSystem(Game *game)
        : EntityProcessingSystem(game) {
}

bool InputSystem::checkEntity(Entity *entity) {
    return !entity->hasComponent<DestroyComponent>() &&
            entity->hasComponent<PositionComponent>() &&
            entity->hasComponent<RotationComponent>() &&
            entity->hasComponent<PhysicsComponent>() &&
            entity->hasComponent<InputComponent>() &&
            entity->hasComponent<PlayerStatusComponent>();
}

void InputSystem::processEntity(Entity *entity) {
    auto inputComp = entity->getComponent<InputComponent>();
    auto posComp = entity->getComponent<PositionComponent>();
    auto rotComp = entity->getComponent<RotationComponent>();
    auto physComp = entity->getComponent<PhysicsComponent>();
    auto playerStatusComp = entity->getComponent<PlayerStatusComponent>();

    btRigidBody *rigidBody = physComp->getRigidBody();
    btVector3 velocity = rigidBody->getLinearVelocity();

    // TODO: currently, forward & backward event will override 
    // the front and right velocity generated by the physics.
    // Only velocity on the z axis is taken from the physics calc

    btVector3 walkDir = getViewDirection(rotComp->getRotation());

    // construct local coordinate system
    btVector3 front = walkDir;
    btVector3 right = front.cross(btVector3(0, 0, 1));
    right.normalize();
    // do not calculate head vector, since gravity is always neg z

    btVector3 localVelocity(0.0, 0.0, 0.0);

	

/*    JetpackComponent *jetComp = entity->getComponent<JetpackComponent>();

    if (jetComp != nullptr) {
        if (inputComp->isJumping()) {

            if (!jetComp->activateJetpack()) {
                jetComp->refillJetpack();
            } else {
                if (velocity.getZ() > VELOCITYCAP) {
                    velocity.setZ(VELOCITYCAP);
                } else {
                    velocity.setZ(velocity.getZ() + VELOCTIYACCELERATION);
                }
            }
        } else {
            jetComp->refillJetpack();
        }
    }*/

	const float runningSpeed = EntityConfigLookup::get(entity->getType()).getFloat("running-speed");
	bool isMoving = false;

	if (inputComp->isMovingForward()) {
		localVelocity.setY(runningSpeed);
		isMoving = true;
	} else if (inputComp->isMovingBackward()) {
		localVelocity.setY(-runningSpeed);
		isMoving = true;
	} else {
		localVelocity.setY(0);
	}

	if (inputComp->isMovingLeft()) {
		localVelocity.setX(-runningSpeed);
		isMoving = true;
	} else if (inputComp->isMovingRight()) {
		localVelocity.setX(runningSpeed);
		isMoving = true;
	} else {
		localVelocity.setX(0);
	}


    btVector3 worldVelocity(right * localVelocity.getX() + front * localVelocity.getY());
    worldVelocity.setZ(velocity.getZ());

	JumpComponent *jumpComp = entity->getComponent<JumpComponent>();

	if (!playerStatusComp->checkIsKnockBacked() && !jumpComp->checkIsLaunchByJumpPad()) { //don't move if we are knockbacked
        rigidBody->setLinearVelocity(worldVelocity);
    }
	
	//bool jumping = false;
	if (jumpComp != nullptr) {
		if (isMoving == true && !jumpComp->isJumping() && inputComp->isJumping() && !jumpComp->checkIsLaunchByJumpPad()) {
			const float jumpingSpeed = EntityConfigLookup::get(entity->getType()).getFloat("jumping-speed");

			//velocity.setZ(velocity.getZ() + jumpingSpeed);
			rigidBody->applyCentralImpulse(btVector3(0, 0, jumpingSpeed));
			jumpComp->setJumping(true);
			//jumping = true;
		}
	}
}
