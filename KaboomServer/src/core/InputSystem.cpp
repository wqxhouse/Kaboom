#include "InputSystem.h"

#include <btBulletDynamicsCommon.h>

#include <core/EntityManager.h>
#include <core/PositionComponent.h>
#include <core/RotationComponent.h>

#include "Game.h"
#include "InputComponent.h"
#include "PhysicsComponent.h"

#define PI 3.14159265359
#define deg2rad(d) (PI / 180.0 * d)


InputSystem::InputSystem(Game *game)
        : EntitySystem(game) {
}

InputSystem::~InputSystem() {
}

void InputSystem::update(float timeStep) 
{
	for (Entity *entity : game->getEntityManager().getEntityList()) {
		InputComponent *inputCom = entity->getComponent<InputComponent>();
		RotationComponent *rotCom = entity->getComponent<RotationComponent>();
		PositionComponent *posCom = entity->getComponent<PositionComponent>();
		PhysicsComponent *physCom = entity->getComponent<PhysicsComponent>();

		if (inputCom == nullptr || physCom == nullptr) {
			continue;
		}

		btRigidBody *rigidBody = physCom->getRigidBody();
		btVector3 velocity = rigidBody->getLinearVelocity();

		// TODO: currently, forward & backward event will override 
		// the front and right velocity generated by the physics.
		// Only velocity on the z axis is taken from the physics calc

		// forward & backward & left & right w.r.t orientation
		btQuaternion rot0;
		btQuaternion rot1;
		btScalar yaw = rotCom->getYaw();
		btScalar pitch = rotCom->getPitch();
		rot0.setRotation(btVector3(0, 0, 1), deg2rad(-yaw));
		rot1.setRotation(btVector3(1, 0, 0), deg2rad(pitch));
		btQuaternion rot = rot0 * rot1; // order different from osg::Quat
		btVector3 viewDir = quatRotate(rot, btVector3(0, 1, 0));

		// construct local coordinate system
		btVector3 front = viewDir;
		btVector3 right = front.cross(btVector3(0, 0, 1));
		right.normalize();
		// do not calculate head vector, since gravity is always neg z 

		btVector3 localVelocity(0.0, 0.0, 0.0);

		// Define y to be front speed, x to be right speed
		if (inputCom->isMovingForward()) {
			localVelocity.setY(1);
		}
		else if (inputCom->isMovingBackward()) {
			localVelocity.setY(-1);
		}
		else {
			localVelocity.setY(0);
		}

		if (inputCom->isMovingLeft()) {
			localVelocity.setX(-1);
		}
		else if (inputCom->isMovingRight()) {
			localVelocity.setX(1);
		}
		else {
			localVelocity.setX(0);
		}

		btVector3 worldVelocity(right * localVelocity.getX() + front * localVelocity.getY());
		worldVelocity.setZ(velocity.getZ());

		rigidBody->setLinearVelocity(worldVelocity);

		if (inputCom->isFiring()) {
			Entity *bomb = game->getBombFactory().createBomb(
                posCom->getX() + viewDir.getX(),
                posCom->getY() + viewDir.getY(),
                posCom->getZ() + viewDir.getZ(),
                viewDir.getX() * 5, // TODO: Change launch speed
                viewDir.getY() * 5,
                viewDir.getZ() * 5);
			game->addEntityToWorld(bomb);
			game->getGameServer().sendSpawnEvent(bomb);
		}
	}
}
